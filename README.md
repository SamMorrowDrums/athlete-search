# Young Athlete Data Storage & Search

I have created a simple JSON API that can be queried in the browser or with `curl`. You can search on all the suggested values:

- Name `localhost:8080/records/search?name=something` for partial matches
- Name `localhost:8080/records/search?strict=true&name=something` for exact matches
- Age range: `localhost:8080/records/search?minAge=16&maxAge=20`
    - the interface could then implement the ranges
- Skill(s) `localhost:8080/records/search?skills=tennis,baseball,water%20sports`
- Professional experience (in years) `localhost:8080/records/search?experience=10`
- Limit `localhost:8080/records/search?limit=1` limit the number of records returned default 100

All query string options can be combined, naturally.

### Easy Setup

If you have all the pre-requisites you can just run the RUN_ME script:

- docker-compose version ^1.11
- docker ^17.x
- python 3
- MongoDB CLI tools / mongoimport

_if port 27017 or 8080 are taken_ you should export env:

```sh
MONGO_PORT=<AVAILABLE PORT>
SERVER_PORT=<AVAILABLE PORT>
```

Run everything (the script stays running until you press Enter to clean up at the end):

```sh
./RUN_ME.sh
```

With curl or your browser visit [localhost:8080/](localhost:8080/)

You can also change the number of records, generated by the Python script by changing the argument that is a number in `./RUN_ME.sh`.

### Alternative Setup

Otherwise you can get by with using your local/available MongoDB and Node.JS

```sh
mongoimport --db athletes --collection categories --jsonArray --file ./data/sample-categories.json
mongoimport --db athletes --collection records --jsonArray --file ./data/sample-people.json
mongo localhost/athletes ./data/setup-data.js
mongo localhost/athletes ./data/create-indexes.js
npm install
node index.js
```

To change collections and other settings, look at the ENV used in `config.js`

## Data Design

For this short timeframe, I decided to go for the simple hipster solution, and chuck the data into MongoDB. This offers speed and flexability, however trade-offs become more complex if the dataset has lots of relations, and if there is a lot of traffic. I think certainly there are some powerful query tools in Postgres and other SQL dbs that would have been helpful.

The thing I'm the least happy with is the experience field, which I'm generating from the first and last championship. In SQL I could have added a trigger on insert at least to calculate the value reliably.

The API could easily be maintained, while swapping out the data-store, so we are certainly not tied to this choice.

We have just two collections:

```javascript
const recordSchema = new Schema({
  name:  String,
  birthdate: Date,
  skills: [String],
  championships: [{year: Number, name: String}],
  experience: Number
});
```

The categories are the stored, to provide lists for wider searches, so that "Extreme Sports" matches "Snowboarding" and "Skateboarding" etc. but not vice versa.

```javascript
const categorySchema = new Schema({
  name:  String,
  skills: [String]
});
```
